## 目标
- 在存在横向滚动的宽表（字段多、列多）场景下，打印预览应能展示全部列内容。
- 兼容父页面与同源子页面（iframe），并保留现有打印生命周期与日志体系。

## 问题特性
- 浏览器打印仅做纵向分页，不会自动“横向分页”。超宽内容常被裁剪或保持滚动宽度。
- 解决思路需在打印媒体阶段将横向滚动转化为可打印的版式：要么缩放到页面宽度，要么按列分段拆分。

## 总体方案（双轨并行，按宽度自适应）
1. 方案A：按页面宽度自动缩放（优先）
   - 在 `@media print` 和 `beforeprint` 阶段，计算可打印宽度与表格实际宽度的比值 `ratio`，对表格所在区域应用 `transform: scale(ratio)` 与 `transform-origin: top left`。
   - 配合 `@page` 设置横向纸张（如 `A4 landscape`）提升可用宽度，适用于“中度超宽”的表格。
   - 打印后清理 scale 并恢复布局。

2. 方案B：列分页（超宽表格保证可读性）
   - 在 `beforeprint` 阶段按列宽将表格拆分为多个“列切片快照”，每个快照仅展示一段列范围，并纵向排列。
   - 具体做法：为每个切片克隆一份表格结构，使用 `nth-child`（或 colgroup）隐藏不在该切片范围内的列；在打印媒体下隐藏原始宽表，只显示切片快照。
   - 适用于极端宽表，避免字体过小影响可读性。

## 技术要点
- 打印媒体下统一移除横向滚动：`.print-hscroll { overflow: visible !important; }`，并确保容器 `width: auto; max-width: none;`。
- 处理粘性头/冻结列：在 `@media print` 将 `position: sticky` 调整为 `position: static`，去除左右冻结遮罩，避免切片/缩放时偏移异常。
- 子页面兼容：沿用现有的 `postMessage` + 显式方法桥接机制，在子页面中也执行同样的缩放或列切片逻辑（同源时）。
- 日志与注释：所有新增函数提供函数级注释，并在入口/出口打印结构化日志，保持与现有代码一致。

## 拟修改文件
- `index.html`：
  - 增加打印媒体下的宽表通用样式片段：移除横向滚动、可选横向纸张设置、sticky 处理。
  - 可选：添加一个示例宽表容器（`class="print-hscroll table-wrap"`）用于本地验证。
- `script.js`：新增以下函数（含函数级注释与日志）：
  - `prepareWideTablesForPrint()`：扫描 `.print-hscroll` 区域，测量宽度，自适应选择方案A或方案B，并标记 `dataset` 以便清理。
  - `scaleToPrintableWidth(el)`：计算 `ratio` 并对元素应用 scale，记录原状态。
  - `buildTableColumnSlices(el)`：按列宽拆分为多段切片，生成打印快照（复用 `#print-clone-root`），并在 `@media print` 隐藏原表。
  - `cleanupWideTablePrint()`：在 `afterprint` 恢复 scale、移除切片快照与状态标记。
  - 在 `triggerPrint()`/`handleBeforePrint()`/`handleAfterPrint()` 中插入对上述函数的调用，确保生命周期完整。
- `child.html`/`child.js`（同源子页面）：
  - 在子页面 `appBeforePrint` 中复用同样逻辑，或由父页面通过克隆体（已有 `buildPrintClones`）来执行列切片，保证子页面宽表也能完整打印。
- `PRINT_PREVIEW_SOLUTION.md`：
  - 新增章节“宽表（横向滚动）打印”说明双轨方案、触发条件、局限与示例代码片段。

## 关键实现草案（示例片段）
```js
// 计算并缩放到可打印宽度
function scaleToPrintableWidth(el) {
  // 通过可视区宽度近似可打印宽度；横向纸张下更宽
  const printable = document.documentElement.clientWidth;
  const content = el.querySelector('table') || el.firstElementChild || el;
  const actual = content.scrollWidth;
  const ratio = Math.min(1, printable / Math.max(1, actual));
  if (ratio < 1) {
    el.dataset.printScaled = '1';
    el.style.transformOrigin = 'top left';
    el.style.transform = `scale(${ratio})`;
  }
}

// 将宽表按列切片生成打印快照
function buildTableColumnSlices(el) {
  const table = el.querySelector('table');
  if (!table) return;
  const root = document.getElementById('print-clone-root');
  const ths = table.querySelectorAll('thead th');
  const cols = ths.length || table.rows[0].cells.length;
  const widths = Array.from(ths.length ? ths : table.rows[0].cells).map(c => c.offsetWidth);
  const printable = document.documentElement.clientWidth;
  const groups = [];
  for (let i = 0, acc = 0, start = 0; i < cols; i++) {
    acc += widths[i] || 100;
    if (acc > printable && i > start) { groups.push([start, i]); start = i; acc = widths[i] || 100; }
    if (i === cols - 1) groups.push([start, i + 1]);
  }
  groups.forEach(([from, to], idx) => {
    const section = document.createElement('div');
    section.className = 'print-clone-section';
    section.innerHTML = `<h2>表格列切片 #${idx + 1}（${from + 1}~${to}列）</h2>`;
    const clone = table.cloneNode(true);
    // 隐藏不在切片范围内的列
    const hideRule = document.createElement('style');
    hideRule.textContent = `
      @media print {
        .slice-hide td:nth-child(n+1):nth-child(-n+${cols}) { /* 占位 */ }
      }
    `;
    // 动态应用：为非范围列加类并隐藏（具体实现将在代码中完善 nth-child 选择器）
    Array.from(clone.rows).forEach(row => {
      Array.from(row.cells).forEach((cell, ci) => {
        if (ci < from || ci >= to) cell.style.display = 'none';
      });
    });
    section.appendChild(clone);
    root.appendChild(section);
  });
  root.style.display = 'block';
  el.dataset.printSliced = '1';
}
```

## 触发策略
- 优先尝试方案A（缩放）。若 `实际宽度/可打印宽度 > 1.6`（阈值可调），改用方案B（列切片）。
- 若表格本身设置了冻结列或 sticky，优先方案B以避免缩放后的遮罩错位。

## 打印样式补充
- 在 `@media print`：
  - `.print-hscroll { overflow: visible !important; width: auto !important; max-width: none !important; }`
  - `table { table-layout: auto; }`（或保留 fixed 并按列宽测量，视项目而定）
  - `.sticky, .freeze { position: static !important; }`（按实际类名）
  - 隐藏原始宽表（当切片模式启用）：`.print-hscroll[data-print-sliced="1"] { display: none !important; }`

## 验证与回滚
- 在父页面添加一个宽表示例，分别验证两种模式：
  - landscape + 缩放能显示全部列；
  - 切片快照纵向排列，所有列分别出现在不同页面段落中。
- 打印后确认：scale 与切片快照被清理，页面恢复原样。

## 交付
- 更新 `index.html` 打印样式与示例段落。
- 更新 `script.js` 新增函数，保证函数级注释与日志。
- 更新 `PRINT_PREVIEW_SOLUTION.md` 增加“宽表打印”章节与代码片段。
